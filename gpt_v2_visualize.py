# -*- coding: utf-8 -*-
"""GPT v2 visualize.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LVYlHuW26CRMuq572_Mt1CL7LejNinBl
"""

!pip install transformers datasets

!pip install twilio fastapi uvicorn python-dotenv

# New version (fixed registration issue)

# ============================================
# HeatCare — SMS-based extreme heat assistant
# ============================================
import re
import json
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone, date
from typing import Optional, Dict, Callable, Tuple, List

# -----------------------------
# System prompt (reference only)
# -----------------------------
SYSTEM_PROMPT = (
    "You are HeatCare, an SMS assistant for the general public before, during, and after extreme heat.\n"
    "- Flow:\n"
    " 1) Start with lightweight registration (ask for name and ZIP and AGE — age is REQUIRED). Do not ask for phone number.\n"
    " 2) Send proactive messages before, during, and after heat waves.\n"
    " 3) Use local real-time heat/forecast info to tailor advice. Keep each SMS <= 2–3 short sentences.\n"
    " 4) If any symptom is reported, schedule periodic check-ins and adapt guidance based on replies (better/same/worse), including symptom-specific tips.\n"
    " 5) If symptoms worsen or severe signs appear (confusion, fainting, trouble breathing), advise calling 911 immediately.\n"
    " 6) If possible, prompt user to respond with a number rather than words.\n"
    " 7) Reply in the user’s language if a translator is available.\n"
    "- Tone: supportive, plain-language, actionable, no medical jargon and no ‘risk level’ labels.\n"
    "- Privacy/consent: collect minimum info; confirm consent to store name/ZIP/age; allow STOP to opt out.\n"
    "- Localize: prefer nearby cooling centers and official guidance.\n"
    "- Include the disclaimer only in the initial welcome."
)

# -----------------------------
# Utilities & configuration
# -----------------------------
# Require NAME, ZIP, and AGE
NAME_ZIP_AGE_REGEX = re.compile(r"^\s*([A-Za-z\-\' ]+)\s*,\s*(\d{5})\s*,\s*(\d{1,3})\s*$")
ZIP_ONLY_REGEX = re.compile(r"^(\d{5})$")
NAME_ONLY_REGEX = re.compile(r"^[A-Za-z\-\' ]{2,}$")
WELCOME_EN = (
    f"Hi! I’m HeatCare. To personalize tips, reply with your name, ZIP, and age like: Alex, 11215, 67. "
    "By replying, you consent to store this info. Reply STOP to opt out."
    "This is general information, not medical advice. Emergencies → 911."
)

ASK_SYMPTOMS_EN = "How are you feeling today? Describe any symptoms in your own words."
CHECKIN_PROMPT_EN = "Quick check—how are you now? Reply: 1=better / 2=same / 3=worse"
EMERGENCY_EN = (
    "Please seek help now. If severe (fainting, confusion, trouble breathing), call 911. "
    "While waiting: move to AC, loosen clothes, and sip water."
)

def detect_lang(text: str) -> str:
    return "non-en" if re.search(
        r"[\u0100-\u024F\u1E00-\u1EFF\u0400-\u04FF\u0590-\u08FF\u0E00-\u0FFF\u1000-\u109F\u1100-\u11FF\u3040-\u30FF\u4E00-\u9FFF]",
        text or ""
    ) else "en"

def localize(translator: Optional[Callable[[str, str], str]], lang: str, english_text: str) -> str:
    if translator and lang != "en":
        try:
            return translator(english_text, lang)
        except Exception:
            pass
    return english_text

def now_utc() -> datetime:
    return datetime.now(tz=timezone.utc)

# -----------------------------
# Heat-wave forecast provider (pluggable)
# -----------------------------
@dataclass
class HeatWaveEvent:
    """A single heat-wave window for a ZIP."""
    event_id: str               # stable ID for dedupe; e.g., 'zip:11215:2025-07-18'
    zip: str
    start_date: date            # inclusive (local date)
    end_date: date              # inclusive
    peak_feels_like_F: int      # peak feels-like temp during event

class HeatWaveForecastProvider:
    """Interface you'll back with your hosted weather API."""
    def get_upcoming_events(self, zip_code: str, as_of: Optional[datetime] = None) -> List[HeatWaveEvent]:
        raise NotImplementedError

# ---- PLACEHOLDER for your hosted API integration ----
class HttpForecastProvider(HeatWaveForecastProvider):
    """
    Stub for a hosted forecast service you control.
    Replace BASE_URL and implement the HTTP call + JSON parsing.
    Expected response shape (example):
      {
        "events": [
          {"start": "2025-07-18", "end": "2025-07-19", "peak_feels_like_F": 103, "id": "nws-xyz-123"}
        ]
      }
    """
    BASE_URL = "https://your-forecast-host.example.com/heatwave"  # TODO: set your endpoint

    def get_upcoming_events(self, zip_code: str, as_of: Optional[datetime] = None) -> List[HeatWaveEvent]:
        # TODO: implement requests.get(f"{self.BASE_URL}?zip={zip_code}&as_of=YYYY-MM-DD")
        # import requests
        # r = requests.get(self.BASE_URL, params={"zip": zip_code, "as_of": (as_of or now_utc()).date().isoformat()}, timeout=5)
        # r.raise_for_status()
        # data = r.json()
        # events = []
        # for e in data.get("events", []):
        #     events.append(HeatWaveEvent(
        #         event_id = f"zip:{zip_code}:{e.get('id') or e['start']}",
        #         zip = zip_code,
        #         start_date = date.fromisoformat(e["start"]),
        #         end_date   = date.fromisoformat(e["end"]),
        #         peak_feels_like_F = int(e["peak_feels_like_F"]),
        #     ))
        # return events
        # For now, return empty placeholder (no events) until you wire it up.
        return []

# Deterministic mock for tests (anchored single event)
@dataclass
class FixedMockForecastProvider(HeatWaveForecastProvider):
    event_start: date
    duration_days: int = 2
    peak_feels_like: int = 103
    def get_upcoming_events(self, zip_code: str, as_of: Optional[datetime] = None) -> List[HeatWaveEvent]:
        ev = HeatWaveEvent(
            event_id=f"zip:{zip_code}:{self.event_start.isoformat()}",
            zip=zip_code,
            start_date=self.event_start,
            end_date=self.event_start + timedelta(days=self.duration_days - 1),
            peak_feels_like_F=self.peak_feels_like
        )
        return [ev]

def relative_phase(d: date, event: HeatWaveEvent) -> Optional[Tuple[str, int]]:
    """
    Returns (phase, days) where phase ∈ {'before','during','after'} and days:
      - before: 3 or 1  (send at T-3/T-1)
      - during: 0       (send once per day during the window)
      - after:  1       (send once at T+1)
    Otherwise None.
    """
    if d < event.start_date:
        delta = (event.start_date - d).days
        if delta in (3, 1):
            return ("before", delta)
        return None
    elif event.start_date <= d <= event.end_date:
        return ("during", 0)
    else:
        delta_after = (d - event.end_date).days
        if delta_after == 1:
            return ("after", 1)
        return None

# -----------------------------
# Risk scoring
# -----------------------------
RISK_THRESH = {"LOW": 0.0, "MED": 0.45, "HIGH": 0.70}

def risk_score(age: Optional[int], feels_like: int, has_symptom: bool, severe: bool) -> Tuple[float, str]:
    score = 0.10
    if feels_like >= 105: score += 0.35
    elif feels_like >= 100: score += 0.25
    elif feels_like >= 95:  score += 0.15
    if age is not None and age >= 65: score += 0.20
    if has_symptom: score += 0.20
    if severe:      score += 0.30
    band = "HIGH" if score >= RISK_THRESH["HIGH"] else ("MED" if score >= RISK_THRESH["MED"] else "LOW")
    return round(score, 2), band

# -----------------------------
# Symptom extractor (hookable) + categorizer
# -----------------------------
def heuristic_extractor(text: str, lang: str) -> Dict[str, object]:
    """Heuristic: detects any symptoms and tags basic categories for tailored advice."""
    t = (text or "").lower().strip()
    word_like = len(re.findall(r"\w+", t))
    has = bool(len(t) >= 12 or word_like >= 2)

    categories = set()
    # English keywords (you can extend or localize via translator)
    kw = {
        "dizziness": ["dizzy", "lightheaded", "light-headed"],
        "headache": ["headache", "migraine"],
        "nausea":   ["nausea", "nauseous", "vomit", "throwing up"],
        "cramps":   ["cramp", "muscle spasm", "spasm"],
        "weakness": ["weak", "fatigued", "exhausted"],
        "confusion":["confused", "disoriented", "can’t think"],
        "breathing":["trouble breathing", "short of breath"],
        "fainting": ["faint", "passed out"],
        "fever":    ["fever", "hot to touch"],
    }
    for cat, words in kw.items():
        if any(w in t for w in words):
            categories.add(cat)

    severe = bool({"confusion","breathing","fainting"} & categories)
    return {"has_symptom": has or bool(categories), "severe": severe, "categories": sorted(categories)}

def compose_symptom_advice(feels_like: int, band: str, categories: List[str]) -> str:
    """Return a compact, symptom-tailored string (≤2 sentences). No disclaimer here."""
    tips = []
    base = f"Feels-like {feels_like}°F. "
    # core hydration/AC guidance
    core = "Sip water or oral rehydration, rest in AC or a cool place."
    # per-symptom snippets (pick at most 2 to keep SMS short)
    per = {
        "dizziness": "Lie down or sit, cool your body (cool cloths/tepid shower).",
        "headache":  "Dim lights and cool down; small sips if nausea.",
        "nausea":    "Small, frequent sips; avoid caffeine/alcohol.",
        "cramps":    "Gently stretch and take electrolytes if available.",
        "weakness":  "Sit or lie down; avoid exertion and heat exposure.",
        "fever":     "Cool cloths/tepid shower; avoid ice baths.",
    }
    severe_alert = "If confusion, fainting, or trouble breathing, call 911."

    chosen = [per[c] for c in categories if c in per][:2]
    sentence = " ".join([core] + chosen).strip()
    # Add band-based hint
    if band == "HIGH":
        sentence += " If you feel worse or can’t keep fluids down, seek urgent care."
    return (base + sentence + (" " + severe_alert if {"confusion","breathing","fainting"} & set(categories) else "")).strip()

# -----------------------------
# Advice composers (no disclaimer except in welcome)
# -----------------------------
def concise_advice(lang: str, translator: Optional[Callable[[str, str], str]], feels_like: int, band: str) -> str:
    msg = (
        f"Feels-like {feels_like}°F near you. "
        "Sip water often, stay in AC or a cooling center. "
        "Rest indoors and avoid outdoor activity."
    )
    if band == "HIGH":
        msg = msg.replace(". Rest indoors", ". If you feel worse or faint/confused, call 911. Rest indoors")
    return localize(translator, lang, msg)

def proactive_message(lang: str, translator: Optional[Callable[[str, str], str]], phase: str, days: int, feels_like: int) -> Optional[str]:
    en = None
    if phase == "before" and days == 3:
        en = (
            f"Heat wave expected in ~3 days (feels-like ~{feels_like}°F). "
            "Check AC/fans, refill water, identify cooling centers, plan rides. "
            "Store electrolytes."
        )
    elif phase == "before" and days == 1:
        en = (
            f"Heat wave tomorrow (feels-like ~{feels_like}°F). "
            "Freeze water, pre-cool rooms, charge phones, shift errands to morning/evening."
        )
    elif phase == "during":
        en = (
            f"High heat today (feels-like ~{feels_like}°F). "
            "Limit outdoor activity 11am–6pm, sip water often, and take AC breaks. "
            "If you feel unwell, reply 3 (worse)."
        )
    elif phase == "after":
        en = (
            f"Heat easing (was ~{feels_like}°F). Keep hydrating and rest. "
            "If you had symptoms, continue cooling and avoid heavy activity today."
        )
    return localize(translator, lang, en) if en else None

# -----------------------------
# State & logging
# -----------------------------
@dataclass
class UserState:
    id: str
    name: Optional[str] = None
    zip: Optional[str] = None
    age: Optional[int] = None
    consent: bool = False
    state: str = "UNREGISTERED"  # UNREGISTERED | CHECK_SYMPTOMS | MONITORING
    lang: str = "en"
    last_symptom_free_text: Optional[str] = None
    next_checkin_at: Optional[datetime] = None
    # Proactive dedupe memory: {(event_id, phase, days) -> True}
    proactive_sent: Dict[Tuple[str, str, int], bool] = field(default_factory=dict)

@dataclass
class LogRecord:
    ts: str
    user_id: str
    direction: str   # 'in' | 'out'
    text: str
    meta: Dict

# -----------------------------
# HeatCare model
# -----------------------------
@dataclass
class HeatCareModel:
    translator: Optional[Callable[[str, str], str]] = None
    symptom_extractor: Optional[Callable[[str, str], Dict[str, object]]] = None
    # Default to a fixed mock that schedules an event in ~3 days; swap to HttpForecastProvider() in prod
    forecast_provider: HeatWaveForecastProvider = field(default_factory=lambda: FixedMockForecastProvider(event_start=now_utc().date() + timedelta(days=3)))

    users: Dict[str, UserState] = field(default_factory=dict)
    logs: List[LogRecord] = field(default_factory=list)

    # ---------- Core ----------
    def _get_user(self, user_id: str) -> UserState:
        if user_id not in self.users:
            self.users[user_id] = UserState(id=user_id)
        return self.users[user_id]

    def _log(self, user_id: str, direction: str, text: str, meta: Optional[Dict] = None):
        self.logs.append(LogRecord(
            ts=now_utc().isoformat(),
            user_id=user_id,
            direction=direction,
            text=text,
            meta=meta or {}
        ))

    def _send(self, to: str, body: str, meta: Optional[Dict] = None):
        print(f"[SMS → {to}] {body}")
        self._log(to, "out", body, meta or {})

    # ---------- Public API ----------
    def handle(self, user_id: str, message: str) -> str:
        user = self._get_user(user_id)
        text = (message or "").strip()
        user.lang = detect_lang(text)
        self._log(user_id, "in", text, {"state": user.state})

        low = text.lower()
        # STOP/START/HELP
        if low == "stop":
            self.users[user_id] = UserState(id=user_id, lang=user.lang)
            reply = localize(self.translator, user.lang, "You’ve been unsubscribed from HeatCare. Reply START to join again.")
            self._send(user_id, reply, {"type": "system"})
            return reply

        if low in {"start", "unstop"}:
            self.users[user_id] = UserState(id=user_id, lang=user.lang)
            reply = localize(self.translator, user.lang, WELCOME_EN)
            self._send(user_id, reply, {"type": "system"})
            return reply

        if low == "help":
            reply = localize(self.translator, user.lang, "HeatCare: reply with your name, ZIP, and age like: Alex, 11215, 67. Reply STOP to opt out.")
            self._send(user_id, reply, {"type": "system"})
            return reply

        # Route
        if user.state == "UNREGISTERED":
            reply = self._handle_unregistered(user, text)
        elif user.state == "CHECK_SYMPTOMS":
            reply = self._handle_check_symptoms(user, text)
        elif user.state == "MONITORING":
            reply = self._handle_monitoring(user, text)
        else:
            reply = localize(self.translator, user.lang, WELCOME_EN)

        self._send(user_id, reply, {"type": "reply", "state": user.state})
        return reply

    # ---------- State handlers ----------
    def _handle_unregistered(self, user: UserState, text: str) -> str:
        m = NAME_ZIP_AGE_REGEX.match(text)
        if m:
            name, zip_code, age_str = m.group(1).strip(), m.group(2), m.group(3)
            age = int(age_str)
            # enforce plausible age (1-120)
            if not (1 <= age <= 120):
                return localize(self.translator, user.lang, "Age must be between 1 and 120. Try again like: Alex, 11215, 67")
            user.name = re.sub(r"\s+", " ", name)
            user.zip = zip_code
            user.age = age
            user.consent = True
            user.state = "CHECK_SYMPTOMS"
            return localize(self.translator, user.lang, f"Thanks {user.name}! Saved ZIP {user.zip}, age {user.age}. {ASK_SYMPTOMS_EN}")

        # Partial inputs -> nudge to full triplet
        if ZIP_ONLY_REGEX.match(text):
            return localize(self.translator, user.lang, "Got your ZIP. Please send your full info like: Alex, 11215, 67")
        if NAME_ONLY_REGEX.match(text):
            return localize(self.translator, user.lang, f"Thanks {text.strip()}! Please include ZIP and age like: {text.strip()}, 11215, 67")

        return localize(self.translator, user.lang, "Please send: Name, ZIP, Age (e.g., Alex, 11215, 67).")

    def _handle_check_symptoms(self, user: UserState, text: str) -> str:
        feels_like = self._estimate_feels_like(user.zip or "00000")

        extractor = self.symptom_extractor or heuristic_extractor
        result = extractor(text, user.lang)
        has_sym = bool(result.get("has_symptom"))
        severe = bool(result.get("severe"))
        categories = list(result.get("categories") or [])

        if severe:
            return localize(self.translator, user.lang, EMERGENCY_EN)

        score, band = risk_score(user.age, feels_like, has_symptom=has_sym, severe=severe)

        if has_sym:
            user.last_symptom_free_text = text
            hours = 2 if band == "HIGH" else (3 if band == "MED" else 6)
            user.next_checkin_at = now_utc() + timedelta(hours=hours)
            user.state = "MONITORING"
            # Tailored advice here:
            return localize(self.translator, user.lang, compose_symptom_advice(feels_like, band, categories))

        # No-symptom brief nudge
        return localize(self.translator, user.lang, f"Today’s peak feels-like ~{feels_like}°F. Plan errands early/late, drink water often, and find AC.")

    def _handle_monitoring(self, user: UserState, text: str) -> str:
        t = text.lower().strip()
        if t in {"1", "2", "3"}:
            t = {"1": "better", "2": "same", "3": "worse"}[t]

        if t in {"better", "same", "worse"}:
            if t == "better":
                user.state = "CHECK_SYMPTOMS"
                user.next_checkin_at = None
                return localize(self.translator, user.lang, "Glad you’re feeling better. Keep sipping water, avoid midday heat, and use AC or cool spaces.")
            if t == "same":
                user.next_checkin_at = now_utc() + timedelta(hours=6)
                return localize(self.translator, user.lang, "Thanks. Keep hydrating, stay in AC, and avoid exertion. If not better, consider contacting a clinician.")
            if t == "worse":
                user.next_checkin_at = None
                return localize(self.translator, user.lang, EMERGENCY_EN)

        # Open-ended update path (re-run extractor for additional tailoring)
        feels_like = self._estimate_feels_like(user.zip or "00000")
        extractor = self.symptom_extractor or heuristic_extractor
        result = extractor(text, user.lang)
        categories = list(result.get("categories") or [])
        user.next_checkin_at = now_utc() + timedelta(hours=6)
        if categories:
            return localize(self.translator, user.lang, compose_symptom_advice(feels_like, "MED", categories))
        return localize(self.translator, user.lang, "Thanks for the update. Keep resting in AC and drinking water. If symptoms persist, contact a clinician.")

    # ---------- Scheduler ----------
    def run_scheduled(self, now: Optional[datetime] = None) -> Tuple[int, int]:
        """
        1) Sends due symptom check-ins.
        2) Sends proactive phase messages for each known heat-wave event:
           - T-3 days, T-1 day, each day during, T+1 day after.
        """
        now = now or now_utc()
        today = now.date()
        sent_checks = 0
        sent_proactive = 0

        # Check-in pings
        for u in self.users.values():
            if u.state == "MONITORING" and u.next_checkin_at and u.next_checkin_at <= now:
                body = localize(self.translator, u.lang, CHECKIN_PROMPT_EN)
                self._send(u.id, body, {"type": "checkin"})
                u.next_checkin_at = now + timedelta(hours=6)
                sent_checks += 1

        # Proactive outreach based on heat-wave windows
        for u in self.users.values():
            if not u.zip:
                continue
            events = self.forecast_provider.get_upcoming_events(u.zip, now)
            for ev in events:
                rp = relative_phase(today, ev)
                if not rp:
                    continue
                phase, days = rp
                key = (ev.event_id, phase, days)
                if key in u.proactive_sent:
                    continue  # already sent this phase for this event

                msg = proactive_message(u.lang, self.translator, phase, days, ev.peak_feels_like_F)
                if msg:
                    self._send(u.id, msg, {"type": "proactive", "event_id": ev.event_id, "phase": phase, "days": days})
                    u.proactive_sent[key] = True
                    sent_proactive += 1

        return sent_checks, sent_proactive

    # ---------- Data export (training) ----------
    def export_jsonl(self, path: str) -> int:
        """
        Writes one JSON object per line with inbound/outbound messages and metadata.
        Only exports users who consented (consent=True).
        """
        count = 0
        consent_users = {uid for uid, u in self.users.items() if u.consent}
        with open(path, "w", encoding="utf-8") as f:
            for rec in self.logs:
                if rec.user_id not in consent_users:
                    continue
                obj = {
                    "ts": rec.ts,
                    "user_id": rec.user_id,
                    "direction": rec.direction,
                    "text": rec.text,
                    "meta": rec.meta,
                    "user_ctx": self._safe_user_ctx(self.users.get(rec.user_id)),
                }
                f.write(json.dumps(obj, ensure_ascii=False) + "\n")
                count += 1
        return count

    def _safe_user_ctx(self, u: Optional[UserState]) -> Dict:
        if not u:
            return {}
        return {
            "zip": u.zip,
            "age": u.age,
            "state": u.state,
            # Keep minimal context by default; avoid exporting name/phone unless policy allows.
        }

    # ---------- Helper ----------
    def _estimate_feels_like(self, zip_code: str) -> int:
        """
        Placeholder for 'current/peak feels-like' estimate.
        When integrating your API, compute today's peak or next 24h max from forecast.
        """
        events = self.forecast_provider.get_upcoming_events(zip_code, now_utc())
        today = now_utc().date()
        for ev in events:
            if (ev.start_date - timedelta(days=3)) <= today <= (ev.end_date + timedelta(days=1)):
                return ev.peak_feels_like_F
        # Fallback if no event nearby: simple ZIP-based heuristic
        try:
            z = int(zip_code)
        except Exception:
            z = 0
        return 95 + (z % 6)

# -----------------------------
# Test: Continuous HeatCare simulation with welcome
# -----------------------------
from datetime import datetime, timedelta, timezone
import time, os

# Instantiate model (uses MockForecastProvider by default)
model = HeatCareModel()

def continuous_simulation_with_welcome(user_id, registration, symptom_sequence, start_time=None, export_path="/tmp/heatcare_logs.jsonl"):
    """
    user_id: string
    registration: "Name, ZIP, Age" or ZIP only
    symptom_sequence: list of tuples (hours_after_registration, user_response)
    start_time: optional datetime to anchor the simulation (UTC). Defaults to now.
    export_path: where to write JSONL transcript at the end.
    """
    print(f"=== Continuous Simulation for {user_id} ===\n")

    # Anchor the simulation clock
    current_time = start_time or datetime.now(tz=timezone.utc)

    # Step 0: Initial welcome message (no inbound yet)
    user = model._get_user(user_id)
    welcome_msg = localize(model.translator, user.lang, WELCOME_EN)
    print(f"[0h] HeatCare: {welcome_msg}\n")

    # Step 1: Registration
    response = model.handle(user_id, registration)
    print(f"[0h] User: {registration}")
    print(f"[0h] HeatCare: {response}\n")

    # Immediately run scheduler at t=0 to send the T-3 proactive warning (Mock provider creates an event at +3 days)
    checks, proactive = model.run_scheduled(now=current_time)
    if checks or proactive:
        print(f"[0h] [System] Sent {checks} check-in(s), {proactive} proactive message(s)")

    # Simulate symptom reporting + scheduled messages over time
    elapsed_total = 0
    for delta_hours, user_msg in symptom_sequence:
        elapsed_total += delta_hours
        current_time += timedelta(hours=delta_hours)

        # Run scheduled proactive/check-ins at this simulated time
        checks, proactive = model.run_scheduled(now=current_time)
        if checks or proactive:
            print(f"[+{elapsed_total}h] [System] Sent {checks} check-in(s), {proactive} proactive message(s)")

        # User sends a message (could be empty string if you just want to advance time)
        response = model.handle(user_id, user_msg)
        print(f"[+{elapsed_total}h] User: {user_msg}")
        print(f"[+{elapsed_total}h] HeatCare: {response}\n")

    # Final state + export
    print(f"Final user state: {model.users[user_id]}")
    n = model.export_jsonl(export_path)
    print(f"\nExported {n} message(s) to: {export_path}")

    # Show the last few JSONL lines for quick inspection (if file exists)
    try:
        tail = []
        with open(export_path, "r", encoding="utf-8") as f:
            for line in f:
                tail.append(line.rstrip("\n"))
        print("\n--- JSONL tail (last 5 lines) ---")
        for line in tail[-5:]:
            print(line)
        print("--- end tail ---")
    except Exception as e:
        print(f"[Export preview skipped: {e}]")

    print("="*60 + "\n")


# -----------------------------
# Example simulation for Alice
# -----------------------------
# NOTE:
# MockForecastProvider defines a heat wave starting ~3 days from 'now' and lasting 2 days.
# The sequence below advances time to hit:
#   - T-3 (at 0h, we run scheduler once)
#   - T-1 (after 48h)
#   - DURING day 1 (after 24h)
#   - DURING day 2 (after 24h)
#   - T+1 (after 24h)
continuous_simulation_with_welcome(
    "alice_user",
    registration="Alice, 10001, 70",
    symptom_sequence=[
        (0,  "I feel dizzy and have a headache"),   # initial symptoms at T-3
        (48, "2"),                                  # T-1 day: user replies "same"
        (24, "3"),                                  # DURING day 1: user replies "worse" -> triggers emergency guidance
        (24, "1"),                                  # DURING day 2: user replies "better"
        (24, "Thanks, feeling okay today")          # T+1 day after the heat wave
    ],
    # Optional: fix a start time for deterministic tests
    start_time=datetime.now(tz=timezone.utc),
    export_path="/tmp/heatcare_logs.jsonl"
)

from itertools import product
import re
import pandas as pd
import matplotlib.pyplot as plt

# -----------------------------
# Model helpers
# -----------------------------
RISK_THRESH = {"LOW": 0.0, "MED": 0.45, "HIGH": 0.70}

def risk_score(age: int, feels_like: int, has_symptom: bool, severe: bool):
    score = 0.10
    if feels_like >= 105: score += 0.35
    elif feels_like >= 100: score += 0.25
    elif feels_like >= 95:  score += 0.15
    if age is not None and age >= 65: score += 0.20
    if has_symptom: score += 0.20
    if severe:      score += 0.30
    band = "HIGH" if score >= RISK_THRESH["HIGH"] else ("MED" if score >= RISK_THRESH["MED"] else "LOW")
    return round(score, 2), band

def heuristic_extractor(text: str, lang: str="en"):
    t = (text or "").lower().strip()
    word_like = len(re.findall(r"\w+", t))
    has = bool(len(t) >= 12 or word_like >= 2)

    categories = set()
    kw = {
        "dizziness": ["dizzy", "lightheaded", "vertigo"],
        "headache": ["headache", "migraine"],
        "nausea":   ["nausea", "vomit"],
        "cramps":   ["cramp", "spasm"],
        "weakness": ["weak", "fatigued", "tired"],
        "confusion":["confused", "disoriented", "can't think"],
        "breathing":["trouble breathing", "short of breath"],
        "fainting": ["faint", "passed out"],
        "fever":    ["fever", "hot to touch"],
    }
    for cat, words in kw.items():
        if any(w in t for w in words):
            categories.add(cat)

    severe = bool({"confusion","breathing","fainting"} & categories)
    return {"has_symptom": has or bool(categories), "severe": severe, "categories": sorted(categories)}

# -----------------------------
# (1) Grid: Age x Temp x Symptom/Severe
# -----------------------------
ages = [20, 40, 65, 80]
feels_like_values = [85, 95, 100, 105]
symptom_flags = [False, True]
severe_flags = [False, True]

grid_results = []
for age, temp, has_sym, severe in product(ages, feels_like_values, symptom_flags, severe_flags):
    score, band = risk_score(age, temp, has_sym, severe)
    grid_results.append({
        "Age": age,
        "FeelsLikeF": temp,
        "HasSymptom": has_sym,
        "Severe": severe,
        "RiskScore": score,
        "RiskBand": band
    })

df_grid = pd.DataFrame(grid_results)
print("\n=== Risk Grid (sample) ===")
print(df_grid.head())

pivot = (
    df_grid.query("HasSymptom == True and Severe == False")
           .pivot(index="Age", columns="FeelsLikeF", values="RiskScore")
           .sort_index()
)
pivot.plot(kind="bar", figsize=(8,4))
plt.title("Risk score vs Age and Feels-like (HasSymptom=True, Severe=False)")
plt.ylabel("Risk Score")
plt.xlabel("Age")
plt.legend(title="Feels-like °F")
plt.tight_layout()
plt.show()

# -----------------------------
# (2) Open-ended texts
# -----------------------------
sample_texts = [
    "", "ok", "Feeling fine",
    "headache and dizzy",
    "I feel weak and very tired",
    "severe confusion and fainting",
    "thirsty",
    "My legs cramp when I walk outside",
    "nausea vomiting trouble breathing",
    "can't stop sweating and feel faint"
]
ages_eval = [25, 40, 65, 80]
temps_eval = [90, 95, 100, 105]

records = []
for txt, age, temp in product(sample_texts, ages_eval, temps_eval):
    sym = heuristic_extractor(txt)
    score, band = risk_score(age, temp, sym["has_symptom"], sym["severe"])
    records.append({
        "Text": txt,
        "Age": age,
        "Temp": temp,
        "HasSymptom": sym["has_symptom"],
        "Severe": sym["severe"],
        "Categories": ", ".join(sym["categories"]),
        "RiskScore": score,
        "RiskBand": band
    })

df_eval = pd.DataFrame(records)
print("\n=== Symptom Evaluation (sample) ===")
print(df_eval.head())

band_counts = (
    df_eval.groupby(["Temp", "RiskBand"])
           .size()
           .reset_index(name="Count")
           .pivot(index="Temp", columns="RiskBand", values="Count")
           .fillna(0)
           .sort_index()
)
band_counts.plot(kind="bar", stacked=True, figsize=(8,4))
plt.title("Distribution of Risk Bands by Temperature")
plt.ylabel("Count of Evaluations")
plt.xlabel("Feels-like °F")
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# -----------------------------
# Heatmap for a single phrase
# -----------------------------
phrase = "headache and dizzy"
subset = df_eval[df_eval["Text"] == phrase]

pivot = subset.pivot(index="Age", columns="Temp", values="RiskScore")

plt.figure(figsize=(6,4))
sns.heatmap(pivot, annot=True, cmap="coolwarm", cbar_kws={"label": "Risk Score"})
plt.title(f"Risk Score for phrase: {phrase}")
plt.ylabel("Age")
plt.xlabel("Feels-like °F")
plt.tight_layout()
plt.show()

# -----------------------------
# Average risk score by phrase
# -----------------------------
avg_risk = (
    df_eval.groupby("Text")[["RiskScore"]]
           .mean()
           .sort_values("RiskScore", ascending=False)
)
print("\n=== Average Risk Score by Phrase ===")
print(avg_risk)

# -----------------------------
# Symptom detection rate by phrase
# -----------------------------
symptom_rate = df_eval.groupby("Text")[["HasSymptom"]].mean()
print("\n=== Symptom Detection Rate by Phrase (0=no, 1=yes) ===")
print(symptom_rate)

# -----------------------------
# Optional: Heatmap for ALL phrases × Temps
# (shows average risk across ages)
# -----------------------------
phrase_temp = (
    df_eval.groupby(["Text", "Temp"])["RiskScore"]
           .mean()
           .reset_index()
           .pivot(index="Text", columns="Temp", values="RiskScore")
)

plt.figure(figsize=(8,6))
sns.heatmap(phrase_temp, annot=True, cmap="YlOrRd", cbar_kws={"label": "Avg Risk"})
plt.title("Average Risk Score by Phrase × Temp (averaged across ages)")
plt.ylabel("Phrase")
plt.xlabel("Feels-like °F")
plt.tight_layout()
plt.show()